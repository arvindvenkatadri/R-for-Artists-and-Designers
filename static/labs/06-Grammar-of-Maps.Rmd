---
title: "Lab-06: The Grammar of Maps"
subtitle: "Where is the Secret Garden?"
author: "Arvind Venkatadri"
date: 22/April/2021
output:
  html_document:
    theme: flatly
    toc: TRUE
    toc_float: TRUE
    toc_depth: 2
    number_sections: TRUE
    code_folding: hide
    code_download: TRUE
abstract: Part of the `R for Artists and Designers` workshop course at the School of Foundation Studies, Srishti Manipal Institute of Art, Design, and Technology, Bangalore.
---


# Introduction

This RMarkdown document is part of the Generic Skills Component  (GSK) of the Course of the  Foundation Studies Programme at Srishti Manipal Institute of Art, Design, and Technology, Bangalore India. The material is based on *A Layered Grammar of Graphics* by Hadley Wickham. The course is meant for First Year students pursuing a Degree in Art and Design. 

The intent of this GSK part is to build Skill in coding in R, and also appreciate R as a way to metaphorically visualize information of various kinds, using predominantly geometric figures and structures.

All RMarkdown files combine code, text, web-images, and figures developed using code. Everything is text; code chunks are enclosed in **fences** (```)


# Goals

At the end of this Lab session, we should:
- know the types and structures of `spatial data` and be able to work with them
- understand the basics of modern spatial packages in R
- be able to specify and download spatial data from the web, using R from sources such as `naturalearth` and `Open Streep Map`
- plot *static* and *interactive* maps using `ggplot`, `tmap` and `leaflet` packages
- add symbols and markers for places and regions of our own interest in these maps.
- see directions for further work (e.g. maps + networks together)



# Pedagogical Note

The method followed will be based on
[PRIMM](https://blogs.kcl.ac.uk/cser/2017/09/01/primm-a-structured-approach-to-teaching-programming/):

-   **PREDICT** Inspect the code and guess at what the code might do,
    **write predictions**
-   **RUN** the code provided and check what happens
-   **INFER** what the `parameters` of the code do and **write comments to explain**. What bells and whistles can you see?
-   **MODIFY** the `parameters` code provided to understand the
    `options` available. **Write comments** to show what you have aimed for and achieved.
-   **MAKE** : take an idea/concept of your own, and graph it.


## Set Up

The `setup` code **chunk** below brings into our coding session **R packages** that provide specific computational abilities and also **datasets** which we can use. 

To reiterate: Packages and datasets are **not** the same thing !! Packages are (small) collections of programs. Datasets are just....information.

# Package related Instructions

 - Install all packages that are flagged by RStudio
 - Run this in your console first:

devtools::install_github("ropensci/rnaturalearthhires")


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Getting Map Data into R
library(osmdata) # Import Open Street Data
library(rnaturalearth)
library(rnaturalearthdata)

# Run this in your console first
#devtools::install_github("ropensci/rnaturalearthhires")
library(rnaturalearthhires)

# 
library(prettymapr) # to search for map data based on location

# Plotting Maps
library(tidyverse) # Maps using ggplot + geom_sf
library(osmplotr) # "Bespoke" Maps using OSM data
library(tmap) # Thematic Maps, static and interactive

# For Spatial Data Frame Processing
library(sf)
```


# Introduction to Maps in R

We will take small steps in making maps using just two of the several map making packages in R.

The steps we will use are:

1. Search for an area of interest ( E.g. using `prettymapr` or similar..)
2. Learn how to access spatial/map data using `osmdata`
3. Plot and dress up our map using `osmplot`, `tmap` and also with `leaflet`.
4. Create interactive maps with `leaflet` using a variety of map data providers. Note: `tmap` can also do interactive maps which we will explore also. 

Bas. Onwards and Map-wards!!

All jargon words will be capitalized and in **bold** font. 

# God made me a BengaluR-kaR...I think

Let's get BLR data into R and see if we can plot an area of interest. Then we can order on Swiggy and...never mind. 


1. Where is my home? Specify a "**BOUNDING BOX**" first, using a rough longitude latitude info directly, or using a place name to search for the long/lat info:

```{r I-am-going-home}
# BLR Bounding Box
# get_bbox needs lat and lon ranges
bbox_1 <- osmplotr::get_bbox(c(77.46,12.83,77.74,13.14))
bbox_2 <- osmdata::getbb("Bangalore, India")
bbox_3 <- getbb("Jayanagar, Bangalore, India")
bbox_1
bbox_2
bbox_3
```


We will use the smaller `bbox_3` from the above, to ensure we have smaller data downloads! 

Within our `bbox` for BLR, we want to download diverse kinds of **FEATURE** data. Remember that a **FEATURE** This is done using the `osmplotr::extract_osm_objects()` command. The main parameters for this command are:

- bbox  
- **KEY / VALUE** pairs (**"TAGS"**) to specify the kind of feature you need  

See [OSM Tags](https://taginfo.openstreetmap.org/) for a nice visual description of popular tags that we can use. Useful keys include:

- building : yes (all), house residential, apartments
- highway: residential, service, track, unclassified, footway, path
- amenity: parking, parking_space, bench; place_of_worship;  restaurant, cafe, fast_food; school, waste_basket, fuel, bank, toilets...
- shop: convenience, supermarket, clothes, hairdresser, car-repair...
- name: actual name of the place e.g. Main_Street, *McDonald's, Pizza Hut, Subway*
- waterway
- natural
- boundary

For example see: [tag : highway](https://taginfo.openstreetmap.org/keys/highway#values)


# Get Map data

We will get the map data from OSM and then save it avoid repeated downloads. So, please copy/paste and run the following commands in your console.
Do not run these commands too many times, UNLESS you have changed your bbox extent.

```{r}
dat_B <- extract_osm_objects (key = "building", bbox = bbox_3)
dat_H <- extract_osm_objects (key = 'highway', bbox = bbox_3)
dat_P <- extract_osm_objects (key = 'park', bbox = bbox_3)
dat_G <- extract_osm_objects (key = 'landuse', value = 'grass', bbox = bbox_3)
dat_T <- extract_osm_objects (key = 'natural', value = 'tree', bbox = bbox_3)
```

## Let us save this data! 

```{r}
write_sf(dat_B, dsn = "dat_B.gpkg", append = FALSE, quiet = FALSE)
write_sf(dat_P, dsn = "dat_P.gpkg", append = FALSE, quiet = FALSE)
write_sf(dat_G, dsn = "dat_G.gpkg", append = FALSE,quiet = FALSE)
write_sf(dat_T, dsn = "dat_T.gpkg", append = FALSE,quiet = FALSE)
##
# write_sf(dat_H, dsn = "dat_H.gpkg", append = FALSE, quiet = FALSE)
```

Yes, the `write_sf(dat_H)` does not seem to work. This is something we need to research and understand. But at least all the other files are saved locally. We will comment it out for now!

Always work from here to avoid repeated downloads from OSM.

## Reading Back the saved Data
```{r}
dat_B <- st_read("./dat_B.gpkg")
dat_P <- read_sf("./dat_P.gpkg")
dat_G <- read_sf("./dat_G.gpkg")
dat_T <- read_sf("./dat_T.gpkg")

```


## Let's look at the data

```{r}
# How many buildings?
nrow(dat_B)
dat_B$geometry
class(dat_B$geometry)
```

So `dat_B` has `r nrow(dat_B)` buildings and their geometry is naturally a POLYGON type of geometry column. 


## Your Turn 1

Do this check for all the other spatial data, in the code chunk below. 
What kind of `geometry` column does each dataset have?


```{r YOUR-TURN-1}



```




## What Other Kinds of Data could we get from OSM?

`osm_structures` returns a data.frame of OSM structure types, associated key-value pairs, unique suffices which may be appended to data structures for storage purposes, and suggested colours.

```{r}
osmplotr::osm_structures()
```



## My first Map in R

We could quickly plot this using the package `osmplotr`. However, in my ( i.e. Arvind's opinion ) it is not as flexible as other packages. Maybe I need to study it in more detail. 

So we will continue with `ggplot` and `geom_sf()` :

```{r}

blr_map <- ggplot() +
  geom_sf(data = dat_B, colour = "orange") +  # POLYGONS
  geom_sf(data = dat_H, col = "gray20") +     # LINES
  geom_sf(data = dat_G, col = "darkseagreen1") + # POLYGONS
  geom_sf(data = dat_P, col = "darkseagreen") +  # POLYGONS
  geom_sf(data = dat_T, col = "green")        # POINTS
blr_map


```


Note how `geom_sf` is capable of handling *any* geometry in the `sfc` column !! 

> `geom_sf()` is an unusual geom because it will draw different geometric objects depending on what simple features are present in the data: you can get points, lines, or polygons.

So there, we have our first map!


# Map using `tmap` package

We can also create a map using a package called `tmap`. Here we also have the option of making the map *interactive*.

`tmap` plots are made with code in "groups": each group starts with a `tm_shape()` command. 

```{r using tmap}
# Group-1
tm_shape(dat_B) +
  tm_fill(col = "mediumblue") +

#Group-2
tm_shape(dat_H) +
  tm_lines(col = "gold") +

#Group-3  
tm_shape(dat_G) +
  tm_polygons(col = "limegreen") +
  
#Group-4  
tm_shape(dat_P) +
  tm_polygons(col = "limegreen") +

#Group-5  
tm_shape(dat_T) +
  tm_dots(col = "green")
```


How do we make this map interactive? One more line of code !! Add this line in your console and then run the above chunk again

tmap_mode("view")


# Using data from `tmap`

Let's plot a first map using datasets built into `tmap`. 

`tmap` has a few built-in spatial datasets: `World` and `metro`, `rivers`, `land` and a few others. Check help on these.

```{r World_Data_tmap}
data("World")
head(World, n = 3)
```

We have several 14 attribute variables in `World`. Attribute variables such as `gdp_cap_est`, `HPI` are numeric. Others such as `income_grp` appear to be factors. 
`iso_a3` is the standard three letter name for the country. 


```{r World_metro_tmap}
data("metro")
head(metro, n = 3)
```

Here too we have attribute variables for the metros, and they seem predominantly numeric. Again `iso_a3` is the three letter name for the city.



```{r My-Static-World}
tmap_mode("plot") # Making this a static plot

# Group 1
tm_shape(World) + # dataset = World. 
    tm_polygons("HPI") + # Colour polygons by HPI numeric variable

  # Note the "+" sign continuation
  
# Group 2
tm_shape(metro) + # dataset = metro
  tm_bubbles(size = "pop2030", 
             col = "red") 
# Plot cities as bubbles
# Size proportional to numeric variable `pop2030`
```



```{r My Interactive Water Colour World}
tmap_mode("view") # Change to Interactive


# Let's use WaterColor Map this time!!
tm_tiles("Stamen.Watercolor") + # Watercolor map only with interactive
tm_shape(World) +
    tm_polygons("HPI") +
  
  
tm_shape(metro) + 
  tm_bubbles(size = "pop2030", 
             col = "red")
```

## Using data from `rnaturalearth`

```{r spatial_data}
india <- 
  ne_states(country =  "india", 
            geounit = "india", 
            returnclass = "sf")

india_neighbours <- 
  ne_states(country = (c("india", "sri lanka", "pakistan",
                         "afghanistan", "nepal","bangladesh")
                       ),
            returnclass = "sf")

```


Let's look at the attribute variable columns to colour our graph and to shape our symbols:

```{r}
names(india)
names(india_neighbours)

# Look only at attributes
india %>% st_drop_geometry() %>% head()
india_neighbours%>% st_drop_geometry() %>% head()
```


## Map 1
```{r Map_1}
tmap_mode("view")

# Plot the Neighbours
tm_shape(World %>% dplyr::filter(iso_a3 %in% c("IND", "AFG", "PAK", "NPL", "BGD", "LKA"))) +
  tm_borders() +
  
# Plot India
  tm_shape(india) +
  tm_polygons("name",legend.show = FALSE) +
  
# Plot Neighbours
  tm_shape(india_neighbours) +
  tm_polygons("name", legend.show = FALSE) +
  
# Plot the cities in India alone
  tm_shape(metro %>% dplyr::filter(iso_a3 == "IND")) +
  tm_dots(size = "pop2020",legend.size.show = FALSE) +
  tm_layout(legend.show = FALSE) +
  tm_credits("Geographical Boundaries are not accurate",
             size = 0.5,
             position = "right") +
  tm_compass(position = c("right", "top")) +
  tm_scale_bar(position = "left") +
  tmap_style("watercolor") 

#Try other map styles
#cobalt #gray #white #col_blind #beaver #classic #watercolor #albatross #bw

```


## Your Turn 2

Can you try to download a map area of your home town and plot it as we have above?

## Adding my favourite Restaurants to the map
Is it time to order on Swiggy...

Let us adding interesting places to our map: say based on your favourite restaurants etc. We need restaurant data: lat/long + name + maybe type of restaurant. This can be manually created ( like all of OSMdata ) or if it is already there we can download using *key-value* pairs in our OSM data query.

```{r restaurant_data_1}
dat_R <- extract_osm_objects(bbox = bbox_3, 
                             key = "amenity", 
                             value = "restaurant", 
                             return_type = "point") #<<
# Save the data for future use
write_sf(dat_R, dsn = "dat_R.gpkg",append = FALSE, quiet = FALSE)

```

Note the `return_type` parameter: we want the location and **not** the **building** in which the restaurant is!!

## Reading the saved Restaurant Data

```{r}
dat_R <- st_read("./dat_R.gpkg")
```



```{r restaurant_data_2}
# How many restaurants have we got?
dat_R %>% nrow()
```

```{r restaurant_data_3}
names(dat_R)

```
These are the columns in the Restaurant Data

```{r restaurant_data_4}
# Let's look at the `cuisine` column! 
# ( I want pizza...)
dat_R$cuisine
```

So let us plot the restaurants as POINTs using the `dat-R` data we have downloaded. The `cuisine` attribute looks interesting; let us colour the POINT based on the `cuisine` offered at that restaurant. 

<div class="panel panel-success">
  <div class="panel-heading">The `cuisine` attribute:</div>
  <div class="panel-body">
Note: The `cuisine` variable has more than one entry for a given restaurant.  We use `tidyr::separate()` to make multiple columns out of the cuisine column and retain the first one only. Since the entries are badly entered using both ";" and "," we need to do this twice ;-()
  </div>
</div>

```{r}
dat_R <- dat_R %>% 
  drop_na(cuisine) %>% # Knock off nondescript restaurants
  
  # Some have more than on classification ;-()
  # Separated by semicolon or comma, so....
  separate(col = cuisine, into = c("cuisine", NA, NA), sep = ";") %>% 
  separate(col = cuisine, into = c("cuisine", NA, NA), sep = ",")

# Finally good food?
dat_R$cuisine
```

Now let's plot the Restaurants as POINTs:

```{r}
# http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
# 
ggplot() + 
  geom_sf(data = dat_B, colour = "burlywood1") + 
  geom_sf(data = dat_H, colour = "gray80") +
  geom_sf(data = dat_R %>% drop_na(cuisine), aes(fill = cuisine), colour = "black", shape = 21) + 
  theme(legend.position = "right") +
  labs(title = "Restaurants in South Central Bangalore",
       caption = "Based on osmdata")
```


We could have done a (much!) better job, by combining cuisines into simpler and fewer categories, but that is for another day!! 

By now we know that we can use `geom_sf()` multiple number of times with different datasets to create layered maps in R.



# Scope and Packages for Exploration!!

### sfnetworks
### mapsf
### ggspatial


# Resources

1. Emine Fidan, [Guide to Creating Interactive Maps in R](https://bookdown.org/eneminef/DRR_Bookdown/)

2. Nikita Voevodin,[R, Not the Best Practices](https://bookdown.org/voevodin_nv/R_Not_the_Best_Practices/maps.html)


# Assignments

1. Draw a map of your home-town with your favourite restaurants shown. Pop-ups for each restaurant will win bonus points. 

### Inspiration

1. Burkhart, Christian. n.d. “Streetmaps.” [StreetMaps](https://ggplot2tutor.com/tutorials/streetmaps)

![](https://ggplot2tutor.com/static/093466a0f94f04f36e2c028fe7ae3f23/fd84e/maps.png)

2. *Making Vector Maps*, Computing for the Social Sciences, [Univ. of Chicago](https://cfss.uchicago.edu/notes/vector-maps/)
