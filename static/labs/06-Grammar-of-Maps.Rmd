---
title: "Lab-06: The Grammar of Maps"
subtitle: "Where is the Secret Garden?"
author: "Arvind Venkatadri"
date: 22/April/2021
output:
  html_document:
    theme: flatly
    toc: TRUE
    toc_float: TRUE
    toc_depth: 2
    number_sections: TRUE
    code_folding: hide
    code_download: TRUE
abstract: Part of the `R for Artists and Designers` workshop course at the School of Foundation Studies, Srishti Manipal Institute of Art, Design, and Technology, Bangalore.
---


# Introduction

This RMarkdown document is part of the Generic Skills Component  (GSK) of the Course of the  Foundation Studies Programme at Srishti Manipal Institute of Art, Design, and Technology, Bangalore India. The material is based on *A Layered Grammar of Graphics* by Hadley Wickham. The course is meant for First Year students pursuing a Degree in Art and Design. 

The intent of this GSK part is to build Skill in coding in R, and also appreciate R as a way to metaphorically visualize information of various kinds, using predominantly geometric figures and structures.

All RMarkdown files combine code, text, web-images, and figures developed using code. Everything is text; code chunks are enclosed in **fences** (```)


# Goals

At the end of this Lab session, we should:
- know the types and structures of `spatial data` and be able to work with them
- understand the basics of modern spatial packages in R
- be able to specify and download spatial data from the web, using R
- plot *static* and *interactive* maps using `ggplot`, `tmap` and `leaflet` packages
- add symbols and markers for places and regions of our own interest in these maps.
- see directions for further work (e.g. maps + networks together)



# Pedagogical Note

The method followed will be based on
[PRIMM](https://blogs.kcl.ac.uk/cser/2017/09/01/primm-a-structured-approach-to-teaching-programming/):

-   **PREDICT** Inspect the code and guess at what the code might do,
    **write predictions**
-   **RUN** the code provided and check what happens
-   **INFER** what the `parameters` of the code do and **write comments to explain**. What bells and whistles can you see?
-   **MODIFY** the `parameters` code provided to understand the
    `options` available. **Write comments** to show what you have aimed for and achieved.
-   **MAKE** : take an idea/concept of your own, and graph it.


## Set Up

The `setup` code **chunk** below brings into our coding session **R packages** that provide specific computational abilities and also **datasets** which we can use. 

To reiterate: Packages and datasets are **not** the same thing !! Packages are (small) collections of programs. Datasets are just....information.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Getting Map Data into R
library(osmdata) # Import Open Street Data
library(rnaturalearth)

library(prettymapr) # to search for map data based on location

# Plotting Maps
library(tidyverse) # Maps using ggplot + geom_sf
library(osmplotr) # "Bespoke" Maps using OSM data
library(tmap) # Thematic Maps, static and interactive

# For Spatial Data Frame Processing
library(sf)

# For Presentation Ease
library(xaringanExtra)

```

```{r echo=FALSE, include=FALSE}
xaringanExtra::use_webcam()
use_broadcast()
use_extra_styles(hover_code_line = TRUE, mute_unhighlighted_code = FALSE)
```


# Introduction to Maps in R

We will take small steps in making maps using just two of the several map making packages in R.

The steps we will use are:

1. Search for an area of interest ( E.g. using `prettymapr` or similar..)
2. Learn how to access spatial/map data using `osmdata`
3. Plot and dress up our map using `osmplot`, `tmap` and also with `leaflet`.
4. Create interactive maps with `leaflet` using a variety of map data providers. Note: `tmap` can also do interactive maps which we will explore also. 

Bas. Onwards and Map-wards!!


# God made me a BengaluR-kaR...I think

Let's get BLR data into R and see if we can plot an area of interest. Then we can order on Swiggy and...never mind. 

Where is my home? Specify a "bounding box" first, using a rough longitude latitude info directly, or using a place name to search for the long/lat info:

```{r I_am_going_home}
# BLR Bounding Box
# get_bbox needs lat and lon ranges
bbox <- osmplotr::get_bbox(c(77.56,12.93,77.63,12.96))

bbox_l <- osmdata::getbb("Bangalore, India") # LARGE
bbox_p <- prettymapr::searchbbox("Bangalore") # ALSO LARGE
bbox
bbox_l
bbox_p # identical with bbox_l
```
We will use the smaller `bbox` from the above, to ensure we have smaller data downloads! 

Within our bbox for BLR, we want to download diverse kinds of FEATURE data. This is done using the `osmplotr::extract_osm_objects()` command. The main parameters for this command are:

- bbox  
- key / value pairs (**"tags"**) to specify the kind of feature you need  

See [OSM Tags](https://taginfo.openstreetmap.org/) for a nice visual description of popular tags that we can use. Useful keys include *building, place, amenity, shop, waterway, natural, boundary, and highway*.

For example see: [tag : highway](https://taginfo.openstreetmap.org/keys/highway#values)

```{r get_osm_map_data, cache = TRUE, message=FALSE}
# Get Map data

dat_B <- extract_osm_objects (key = "building", bbox = bbox) 
dat_H <- extract_osm_objects (key = 'highway', bbox = bbox)
dat_P <- extract_osm_objects (key = 'park', bbox = bbox)
dat_G <- extract_osm_objects (key = 'landuse', value = 'grass', bbox = bbox)
dat_T <- extract_osm_objects (key = 'natural', value = 'tree', bbox = bbox)


```
## Let's look at the data

```{r}
# How many buildings?
nrow(dat_B)
dat_B$geometry
class(dat_B$geometry)
```
So `dat_B` has `r nrow(dat_B)` buildings and their geometry is naturally a POLYGON type of geometry column. 

Do this check for all the other spatial data.  
What kind of `geometry` column does each dataset have?

```{r YOUR_TURN_1}



```


## Your Turn 1
-  
-  



## What else could we get from OSM?

`osm_structures` returns a data.frame of OSM structure types, associated key-value pairs, unique suffices which may be appended to data structures for storage purposes, and suggested colours.

```{r}
osm_structures()
```



## My first Map in R

We could quickly plot this using the package `osmplotr`. However, in my ( i.e. Arvind's opinion ) it is not as flexible as other packages. Maybe I need to study it in more detail. 

So we will continue with `ggplot` and `geom_sf()` :

```{r}

blr_map <- ggplot() +
  geom_sf(data = dat_B, colour = "orange") +  # POLYGONS
  geom_sf(data = dat_H, col = "gray20") +     # LINES
  geom_sf(data = dat_G, col = "darkseagreen1") + 
  geom_sf(data = dat_P, col = "darkseagreen") +
  geom_sf(data = dat_T, col = "green")        # POINTS
blr_map


```


Note how `geom_sf` is capable of handling *any* geometry in the `sfc` column !! 

> `geom_sf()` is an unusual geom because it will draw different geometric objects depending on what simple features are present in the data: you can get points, lines, or polygons.

So there, we have our first map!

Now we need to add things to it, things that **matter to us** !!

## Your Turn 2

Can you try to download a map area of your home town and plot it as we have above?




## Adding my favourite "area" to the map

We can create areas of interest around the map. 
For a start: we are simply going to *zoom in* to an area, define a small rectangle,  and say that is our area of interest. 

This area then needs to go **Through the Looking Glass** and become part of the projection of `dat_B`!!

We can then try more complex queries and plots based on your favourite restaurants etc. 

```{r shapes_on_maps}

my_area <- bbox %>% 
  
  # zooming in within our bounding box area
  prettymapr::zoombbox(factor = 8, offset = c(0,0)) 
my_area
bbox
```

OK, `my area` is small and contained inside my `bbox`. So `zoombbox` works. 

Now to convert `my_area` into a spatial dataframe using `sf` and add it to the `blr_map` plot:

```{r}

# Make a matrix
my_area_in_blr <- matrix(
  c(
  my_area["x", "min"],
  my_area["x", "max"],
  my_area["x", "max"],
  my_area["x", "min"],
  my_area["x", "min"],
  my_area["y", "min"],
  my_area["y", "min"],
  my_area["y", "max"],
  my_area["y", "max"],
  my_area["y", "min"]),
  ncol = 2) 
my_area_in_blr
```
Note the A-B-C-D-A structure of specifying an enclosed area. Last vertex is the same as start vertex.


```{r}
# Convert to list since POLYGON needs a list
my_area_in_blr <- 
  
  my_area_in_blr %>% 
  list() %>% 

# Convert to POLYGON
  st_polygon() %>% 
  
# Convert POLYGON to an `sfc` column
# Through the Looking Glass with dat_B
  st_sfc(., crs = st_crs(dat_B)) %>% 
  
  # Convert sfc to an sf spatial dataframe. Phew!!
  st_as_sf(.) 
  


my_area_in_blr
```


```{r My_Blr_finally}
blr_map <- 
  blr_map + geom_sf(data = my_area_in_blr, colour = "red")
blr_map

```

We could have created an **arbitrary** area on our map in this way, starting with a matrix and making a spatial data frame, and over-plotting it as a layer on the base map.

We could also add **multiple areas of interest** using ...yes MULTIPOLYGONs !!

## Your Turn 3

Try adding more than one "areas of interest" to your map. 


## Adding my favourite Restaurants to the map
Is it time to order on Swiggy...

Let us adding interesting places to our map: say based on your favourite restaurants etc. We need restaurant data: lat/long + name + maybe type of restaurant. This can be manually created ( like all of OSMdata ) or if it is already there we can download using *key-value* pairs in our OSM data query.

```{r restaurant_data_1}
dat_R <- extract_osm_objects(bbox = bbox, 
                             key = "amenity", 
                             value = "restaurant", 
                             return_type = "point") #<<
```

Note the `return_type` parameter: we want the location and **not** the **building** in which the restaurant is!!


```{r restaurant_data_2}
# How many restaurants have we got?
dat_R %>% nrow()
```

```{r restaurant_data_3}
names(dat_R)

```


```{r restaurant_data_4}
# Let's look at the `cuisine` column! 
# ( I want pizza...)
dat_R$cuisine
```

So let us plot the restaurants as POINTs using the `dat-R` data we have downloaded. The `cuisine` attribute looks interesting; let us colour the POINT based on the `cuisine` offered at that restaurant. 

<div class="panel panel-success">
  <div class="panel-heading">The `cuisine` attribute:</div>
  <div class="panel-body">
Note: The `cuisine` variable has more than one entry for a given restaurant.  We use `tidyr::separate()` to make multiple columns out of the cuisine column and retain the first one only. Since the entries are badly entered using both ";" and "," we need to do this twice ;-()
  </div>
</div>

```{r}
dat_R <- dat_R %>% 
  drop_na(cuisine) %>% # Knock off nondescript restaurants
  
  # Some have more than on classification ;-()
  # Separated by semicolon or comma, so....
  separate(col = cuisine, into = c("cuisine", NA, NA), sep = ";") %>% 
  separate(col = cuisine, into = c("cuisine", NA, NA), sep = ",")

# Finally good food?
dat_R$cuisine
```

Now let's plot the Restaurants as POINTs:

```{r}
# http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
# 
ggplot() + 
  geom_sf(data = dat_B, colour = "burlywood1") + 
  geom_sf(data = dat_H, colour = "gray80") +
  geom_sf(data = dat_R %>% drop_na(cuisine), aes(fill = cuisine), colour = "black", shape = 21) + 
  theme(legend.position = "right") +
  labs(title = "Restaurants in South Central Bangalore",
       caption = "Based on osmdata")
```


We could have done a (much!) better job, by combining cuisines into simpler and fewer categories, but that is for another day!! 

By now we know that we can use `geom_sf()` multiple number of times with different datasets to create layered maps in R.

Let us now try to make **interactive** maps using `tmap`.


# Using `rnaturalearth` and `tmap`

Let's plot a first map using datasets built into `tmap`. Then we can download other datasets from `rnaturalearth` and plot them next.

`tmap` has a few built-in spatial datasets: `World` and `metro`, `rivers`, `land` and a few others. Check help on these.

```{r World_Data_tmap}
data("World")
head(World, n = 3)
```

We have several 14 attribute variables in `World`. Attribute variables such as `gdp_cap_est`, `HPI` are numeric. Others such as `income_grp` appear to be factors. 
`iso_a3` is the standard three letter name for the country. 


```{r World_metro_tmap}
data("metro")
head(metro, n = 3)
```
Here too we have attribute variables for the metros, and they seem predominantly numeric. Again `iso_a3` is the three letter name for the city.


`tmap` plots are made with code in "groups": each group starts with a `tm_shape()` command. 

```{r My_Static_World}
tmap_mode("plot") # Making this a static plot

# Group 1
tm_shape(World) + # dataset = World. 
    tm_polygons("HPI") + # Colour polygons by HPI numeric variable

  # Note the "+" sign continuation
  
# Group 2
tm_shape(metro) + # dataset = metro
  tm_bubbles(size = "pop2020", 
             col = "red") 
# Plot cities as bubbles
# Size proportional to numeric variable `pop2020`
```



```{r My Interactive Water Colour World}
tmap_mode("view") # Change to Interactive

tm_shape(World) +
    tm_polygons("HPI") +
  
  
tm_shape(metro) + 
  tm_bubbles(size = "pop2020", 
             col = "red") +

# Let's use WaterColor Map this time!!
tm_tiles("Stamen.TonerLabels")
```

## Using data from `rnaturalearth`

```{r spatial_data}
india <- 
  ne_states(country =  "india", 
            geounit = "india", 
            returnclass = "sf")

india_neighbours <- 
  ne_states(country = (c("india", "sri lanka", "pakistan",
                         "afghanistan", "nepal","bangladesh")
                       ),
            returnclass = "sf")

```


Let's look at the attribute variable columns to colour our graph and to shape our symbols:

```{r}
names(india)
names(india_neighbours)

# Look only at attributes
india %>% st_drop_geometry() %>% head()
india_neighbours%>% st_drop_geometry() %>% head()
```


## Map 1
```{r Map_1}
tmap_mode("view")

# Plot the Neighbours
tm_shape(World %>% dplyr::filter(iso_a3 %in% c("IND", "AFG", "PAK", "NPL", "BGD", "LKA"))) +
  tm_borders() +
  
# Plot India
  tm_shape(india) +
  tm_polygons("name") +
  
# Plot Neighbours
  tm_shape(india_neighbours) +
  tm_polygons("name") +
  
# Plot the cities in India alone
  tm_shape(metro %>% dplyr::filter(iso_a3 == "IND")) +
  tm_dots(size = "pop2020") +
  tm_layout(legend.outside = TRUE,
            legend.outside.position = "right") +
  tm_credits("Geographical Boundaries are not accurate",
             size = 0.5,
             position = "right") +
  tm_compass(position = c("right", "top")) +
  tm_scale_bar(position = "left") +
  tmap_style("watercolor") 

#Try other map styles
#cobalt #gray #white #col_blind #beaver #classic #watercolor #albatross #bw

```




## Map 2

```{r Map_2}
tm_shape(india_neighbours) + 
  tm_polygons("name") + 
  
  tm_shape( metro %>% dplyr::filter(iso_a3 %in% c("IND","PAK", "LKA", "BGD","NPL"))) +
  tm_dots(size = "pop2020") + 
  tm_layout(legend.show = FALSE) + # no effect
  tmap_options(max.categories = 10) + 
  tm_credits("Geographical Boundaries are not accurate",size = 0.5,position = "center")

```

```{r}
tmap_mode("view")
tm_basemap("Stamen.Watercolor") +
  tm_shape(metro, bbox = "India") + 
  tm_dots(col = "red", 
          # user-chosen group name for layers
          group = "Metropolitan Areas") +
  tm_shape(World) + 
  tm_borders() + 
  tm_tiles(server = "Stamen.TonerLabels", group = "Labels") + # ADDS LABELS!!!
  tm_graticules()

```


# Scope and Packages for Exploration!!

### sfnetworks
### mapsf
### ggspatial


# Resources

1. Emine Fidan, [Guide to Creating Interactive Maps in R](https://bookdown.org/eneminef/DRR_Bookdown/)

2. Nikita Voevodin,[R, Not the Best Practices](https://bookdown.org/voevodin_nv/R_Not_the_Best_Practices/maps.html)


# Assignments

1. What if we have marked our favourite locations on our smartphones, using GPS? Umm...OK have to make our sf:Spatial Data Frame using these coordinates. 
We will need to do this in the same way:
- Create a matrix
- Make POINTs
- Make an sfc
- Convert to sf
- Project in the same way. 

2. Draw a map of your home-town with your favourite restaurants shown. Pop-ups for each restaurant will win bonus points. 

# Inspiration

1. Burkhart, Christian. n.d. “Streetmaps.” [StreetMaps](https://ggplot2tutor.com/tutorials/streetmaps)

![](https://ggplot2tutor.com/static/093466a0f94f04f36e2c028fe7ae3f23/fd84e/maps.png)

2. *Making Vector Maps*, Computing for the Social Sciences, [Univ. of Chicago](https://cfss.uchicago.edu/notes/vector-maps/)
